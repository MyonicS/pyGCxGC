var __index = {"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"pyGCxGC","text":""},{"location":"index.html#overview","title":"Overview","text":"<p>pyGCxGC is a python package for processing of two dimensional Gas Chromatography (GCxGC) data. Presently, it supports generating 2D chromatograms for detectors with one parameter, such as FID.</p> <p> </p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Load 1D Chromatograms from a csv or a pandas dataframe</li> <li>Generate 2D Chromatograms</li> <li>Integrate areas in 2D Chromatograms using .tif masks</li> <li>GUI for generation of masks</li> </ul> <p>\u26a0\ufe0f WARNING: pyGCxGC is under active development. Braking changes can occur. Please report any issues using the Issue Tracker.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>pyGCxGC is not yet available on PyPI. To install the latest development version, clone the repository and install it using pip:</p> <pre><code>git clone https://github.com/MyonicS/pyGCxGC.git\ncd pyGCxGC\npip install .\n</code></pre> <p>in editable mode:</p> <pre><code>pip install -e .\n</code></pre> <p>Note: The GUI functionality requires tkinter, which is included in most Python installations. If you're having issues with the GUI, ensure tkinter is installed on your system.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>Check the Development Notebook to get started, more in-depth docs to be developed.</p>"},{"location":"index.html#usage","title":"Usage","text":""},{"location":"index.html#parsing-and-plotting","title":"Parsing and plotting","text":"<p>To generate a 2D chromatogram object, you need either a csv or padnas dataframe with the retention time in seconds ('Ret.Time[s]') and a column labeled 'Absolute Intensity'.</p> <pre><code>import pyGCxGC as gcgc\nfrom matplotlib import pyplot as plt\n\nchrom = gcgc.parse_2D_chromatogram(\n    'example_data/example_chromatograms/Example_FID.csv',\n    modulation_time=20,\n    sampling_interval='infer'\n)\n\n# Plot the 2D chromatogram\nimport matplotlib.pyplot as plt\nplt.imshow(chrom.chrom_2D, cmap='viridis', extent=chrom.limits, aspect='auto')\nplt.xlabel('Retention time 1 (min)')\nplt.ylabel('Retention time 2 (s)')\nplt.colorbar(label='intensity')\nplt.show()\n</code></pre>"},{"location":"index.html#integrating-a-specific-area","title":"Integrating a specific area","text":"<p>To integrate a specific area, provide a binary mask as .tif file. You can also provide a directory with multiple masks.</p> <pre><code># Integrate using a mask file\nresult = gcgc.integrate_masks(\n    chrom.chrom_2D,\n    masks='example_data/example_masks/Mask_1.tif'\n)\nprint(result)\n</code></pre>"},{"location":"index.html#creating-masks-with-the-gui","title":"Creating Masks with the GUI","text":"<p>The package includes a graphical user interface for creating masks for 2D chromatograms.  The GUI allows you to load a chromatogram, draw regions of interest, and save them as binary mask files (<code>.tif</code>).</p> <p>To launch the GUI from within Python:</p> <pre><code>import pyGCxGC as gcgc\n\n# Launch the mask creator GUI\ngcgc.launch_mask_creator()\n</code></pre> <p>You can also launch it directly from the command line:</p> <pre><code>pygcxgc-maskcreator\n</code></pre> <p>The GUI provides tools to: - Load and visualize 2D chromatograms - Draw masks using selection tools - Add/remove selections to/from masks - Save masks as .tif files for later use with pyGCxGC's masking functions</p> <p>For a detailed tutorial on using the Mask Creator GUI, see the <code>Mask_Creator_GUI.ipynb</code> notebook in the docs.</p> <p>For a finer control of the masks, you can use image processing software such as ImageJ.</p>"},{"location":"citing.html","title":"Citing pyGCxGC","text":"<p>When using pyGCxGC in a scientific publication (...)</p>"},{"location":"citing_work.html","title":"Papers using pyGCxGC","text":"<ul> <li>Refs here</li> </ul>"},{"location":"contributing.html","title":"Contributing","text":"<p>Details on Contributing will go here</p>"},{"location":"contributors.html","title":"Contributors","text":""},{"location":"contributors.html#author","title":"Author","text":"<p>Sebastian Rejman, Utrecht University</p>"},{"location":"examples.html","title":"Examples","text":""},{"location":"examples.html#use-cases-will-go-here","title":"Use cases will go here","text":""},{"location":"roadmap.html","title":"Roadmap","text":"<p>Features to be implemented</p>"},{"location":"example_docs/about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"example_docs/about/changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"example_docs/about/changelog.html#001","title":"[0.0.1]","text":""},{"location":"example_docs/about/changelog.html#added","title":"Added","text":"<ul> <li>The initial release!</li> </ul>"},{"location":"example_docs/about/license.html","title":"License","text":"LICENSE.md<pre><code>MIT License\n\nCopyright 2025 Sebastian Rejman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"example_docs/github/commits.html","title":"Saving Your Work","text":"<p>There are still a few more steps left, but at this point you will want to make sure to save your work!</p>"},{"location":"example_docs/github/commits.html#pushing-your-changes","title":"Pushing Your Changes","text":"<p>Commit any changes you've made and push them to your repository</p> <p>If you are using a program like GitKraken, this will involve the following steps:</p> <ol> <li>Save your work.</li> <li>Recommended: make a new branch for your work (e.g. <code>develop</code>)</li> <li>Click \"Stage all changes\".</li> <li>Add a helpful commit message.</li> <li>Commit the changes.</li> <li>Click \"push\".</li> </ol> <p>Tip</p> <p>It is advisable to make changes in a new branch rather than in <code>main</code> so that you can ensure your unit tests pass before the code is merged into the codebase.</p> <p>Then go on GitHub to see your changes. Assuming you pushed your changes to a new branch, you'll likely see a message asking if you want to make a Pull Request to merge in your changes into the <code>main</code> branch.</p>"},{"location":"example_docs/github/workflows.html","title":"GitHub Actions","text":""},{"location":"example_docs/github/workflows.html#workflows","title":"Workflows","text":"<p>The last major piece of the puzzle is GitHub Actions, which is an automated suite of workflows that run every time a commit or pull request is made. The GitHub workflows can be found in the <code>.github/workflows</code> folder.</p>"},{"location":"example_docs/github/workflows.html#tests","title":"Tests","text":"<p>The <code>/.github/workflows/tests.yaml</code> file contains the workflow to have GitHub automatically run the full suite of tests on every commit and pull request. For the most basic case outlined here, you do not need to make any modifications (other than, perhaps, the desired Python versions you wish to test on).</p> <p>By default, the test suite is set up to install the following packages:</p> <pre><code>pip install -r tests/requirements.txt\npip install .[dev]\n</code></pre> <p>As you can see above, it will install specific versions of the dependencies outlined in <code>/tests/requirements.txt</code>. Unlike <code>pyproject.toml</code>, you want to include specific versions here so that your test suite is reproducible.</p> <p>The workflow also generates coverage reports in both XML and HTML formats. These reports are uploaded as artifacts and can be accessed from the Actions tab in your GitHub repository. This allows you to track which parts of your code are being tested without requiring external services.</p> <p>The <code>/.github/dependabot.yml</code> file is set up such that Dependabot will automatically open pull requests to update any versions in your <code>/tests/requirements.txt</code> file as they come out so that your code will always be tested on the newest releases of the various dependencies. This will ensure that your code doesn't break as dependencies update, but if it does, you will know what needs fixing.</p>"},{"location":"example_docs/github/workflows.html#documentation","title":"Documentation","text":"<p>The <code>/.github/workflows/docs.yaml</code> file contains the workflow to have GitHub test the build process for the documentation and deploy it (if enabled).</p> <p>To have your documentation automatically deployed on a GitHub webpage:</p> <ol> <li>Go to the settings page of your repository.</li> <li>Click the \"Pages\" section under \"Code and automation.\"</li> <li>Select \"Deploy from a branch\" under \"Source\"</li> <li>Set the branch to be \"gh-pages\" with \"/ (root)\" as the folder.</li> <li>Wait a minute and refresh the page. You'll see a message that your site is live with a URL to the documentation.</li> </ol> <p></p> <p>Once this process is done, the documentation will be live and will update with each commit.</p>"},{"location":"example_docs/github/workflows.html#release","title":"Release","text":"<p>The <code>/.github/workflows/release.yaml</code> file contains the workflow to have GitHub upload your package to PyPI every time you mint a new release on GitHub. This is a slightly more advanced topic that you can read more about at a later time, but it's there for when you need it.</p>"},{"location":"example_docs/gui/mask_creator.html","title":"Using the Mask Creator GUI","text":"<p>The Mask Creator GUI is a graphical tool for creating masks for 2D chromatograms. These masks can be used to isolate specific regions of interest in a chromatogram for further analysis.</p>"},{"location":"example_docs/gui/mask_creator.html#starting-the-gui","title":"Starting the GUI","text":"<p>There are several ways to start the Mask Creator GUI:</p> <ol> <li> <p>From Python:    <pre><code>import pyGCxGC as gcgc\ngcgc.launch_mask_creator()\n</code></pre></p> </li> <li> <p>From the command line:    After installing pyGCxGC, you can use the provided script:    <pre><code>pygcxgc-maskcreator\n</code></pre></p> </li> </ol>"},{"location":"example_docs/gui/mask_creator.html#using-the-gui","title":"Using the GUI","text":""},{"location":"example_docs/gui/mask_creator.html#loading-a-chromatogram","title":"Loading a Chromatogram","text":"<ol> <li>Click the \"Load Chromatogram File\" button</li> <li>Select a CSV file containing chromatogram data</li> <li>Enter the modulation time in seconds when prompted</li> </ol>"},{"location":"example_docs/gui/mask_creator.html#adjusting-the-display","title":"Adjusting the Display","text":"<p>The Plotting section allows you to customize how the chromatogram is displayed. The controls are arranged in a compact side-by-side layout to minimize vertical space:</p>"},{"location":"example_docs/gui/mask_creator.html#shift-adjustment-left-column","title":"Shift Adjustment (Left Column)","text":"<ul> <li>Enter a shift value (integer) to adjust the phase of the chromatogram</li> <li>This helps align features for better visualization</li> </ul>"},{"location":"example_docs/gui/mask_creator.html#transform-options-right-column","title":"Transform Options (Right Column)","text":"<p>Choose how intensity data is displayed: - Raw: Original intensity values (best for quantitative analysis) - Square Root: Square root of intensity values (default, good contrast) - Third Root: Third root of intensity values (emphasizes low-intensity features)</p> <p>Click Apply to apply both shift and transform changes to the display.</p>"},{"location":"example_docs/gui/mask_creator.html#drawing-a-mask","title":"Drawing a Mask","text":"<p>The GUI provides three drawing tools:</p> <ul> <li>Rectangle: Click and drag to create a rectangular selection</li> <li>Lasso: Click and drag to create a free-form selection  </li> <li>Polygon: Click to add points, close by clicking near the first point</li> </ul> <p>To add the selection to the mask, click \"Add Selection to Mask\".</p> <p>Note on Coordinate Systems: The GUI properly handles coordinate transformations between the display coordinates and the underlying array coordinates. The y-axis direction differs between these coordinate systems (display coordinates have y increasing upward, while array coordinates have y increasing downward). This ensures that masks are created with the correct orientation.</p>"},{"location":"example_docs/gui/mask_creator.html#user-interface-features","title":"User Interface Features","text":""},{"location":"example_docs/gui/mask_creator.html#tooltips","title":"Tooltips","text":"<p>Hover over buttons and controls to see helpful tooltips explaining their functionality.</p>"},{"location":"example_docs/gui/mask_creator.html#status-bar","title":"Status Bar","text":"<p>The status bar at the bottom of the window provides information about: - Current operation status - Selected region dimensions - Mask coverage statistics - File operations</p>"},{"location":"example_docs/gui/mask_creator.html#colorbar","title":"Colorbar","text":"<p>A colorbar shows the signal intensity scale for the chromatogram display. The scale and label automatically adjust based on the selected transform mode: - Raw: Shows original intensity values - Square Root: Shows square root of intensity values (default) - Third Root: Shows third root of intensity values</p>"},{"location":"example_docs/gui/mask_creator.html#common-tasks","title":"Common Tasks","text":""},{"location":"example_docs/gui/mask_creator.html#creating-a-new-mask","title":"Creating a New Mask","text":"<ol> <li>Load a chromatogram</li> <li>(Optional) Adjust plotting settings:</li> <li>Set shift value if needed</li> <li>Choose transform mode (Raw, Square Root, or Third Root)</li> <li>Click \"Apply\" to update the display</li> <li>Enter a name for your mask in the \"Mask Name\" field</li> <li>Select a drawing tool (Rectangle, Lasso, or Polygon)</li> <li>Draw on the chromatogram by clicking and dragging</li> <li>Click \"Add Selection to Mask\" to add the selection to your mask</li> <li>Repeat steps 4-6 to build up a complex mask</li> <li>Save the mask when finished</li> </ol>"},{"location":"example_docs/gui/mask_creator.html#loading-and-editing-an-existing-mask","title":"Loading and Editing an Existing Mask","text":"<ol> <li>Load a chromatogram with the same dimensions as the one used to create the mask</li> <li>Click \"Load Mask\" and select a .tif mask file</li> <li>Make additional selections and add them to the mask</li> <li>Save the updated mask</li> </ol>"},{"location":"example_docs/gui/mask_creator.html#saving-a-mask","title":"Saving a Mask","text":"<ol> <li>Enter a name for the mask in the \"Mask Name\" field</li> <li>Click the \"Save Mask\" button</li> <li>Select a location to save the mask as a .tif file</li> </ol>"},{"location":"example_docs/gui/mask_creator.html#using-the-created-mask","title":"Using the Created Mask","text":"<p>Once you have created a mask, you can use it with pyGCxGC's masking functions:</p> <pre><code>import pyGCxGC as gcgc\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Load a chromatogram\nchrom = gcgc.parse_2D_chromatogram(\n    'example_data/example_chromatograms/Example_FID.csv',\n    modulation_time=20\n)\n\n# Apply the mask\nmasked_chrom = gcgc.mask_chromatogram(chrom.chrom_2D, 'path/to/your/mask.tif')\n\n# Visualize the masked chromatogram\nplt.figure(figsize=(10,10/1.615))\nplt.imshow(np.sqrt(masked_chrom), cmap='viridis', \n           extent=tuple(chrom.limits), interpolation='bilinear', aspect='auto')\nplt.xlabel('Retention time 1 (min)')\nplt.ylabel('Retention time 2 (s)')\nplt.colorbar(label=r'$\\sqrt{\\mathrm{intensity}}$')\nplt.title('Masked Chromatogram')\nplt.show()\n\n# Integrate the masked region\nresult = gcgc.integrate_2D(masked_chrom)\nprint(f\"Integrated value: {result}\")\n</code></pre>"},{"location":"example_docs/gui/mask_creator.html#integrating-multiple-masks","title":"Integrating Multiple Masks","text":"<p>You can also create multiple masks for different regions and integrate them together:</p> <pre><code># Integrate using multiple masks\nresults = gcgc.integrate_masks(\n    chrom.chrom_2D,\n    masks='path/to/mask/folder/',\n    mask_names='infer'\n)\n\n# Display results as a DataFrame\nimport pandas as pd\nresults_df = pd.DataFrame([results], index=['Sample 1'])\nresults_df\n</code></pre>"},{"location":"notebooks/Develop_notebook.html","title":"Dev Notebook","text":"In\u00a0[24]: Copied! <pre>import pyGCxGC as gcgc\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nfont = {'family' : 'Arial',\n        'weight' : 'normal',\n        'size'   : 9}\nplt.rc('font', **font)\n</pre> import pyGCxGC as gcgc import pandas as pd from matplotlib import pyplot as plt font = {'family' : 'Arial',         'weight' : 'normal',         'size'   : 9} plt.rc('font', **font)  In\u00a0[25]: Copied! <pre>Chromatogram = gcgc.parse_2D_chromatogram('../../example_data/example_chromatograms/Example_FID.csv', modulation_time = 20,\n                                          sampling_interval= 'infer', shift=0,\n                                            normalize='volume', solvent_cutoff=0)\n</pre> Chromatogram = gcgc.parse_2D_chromatogram('../../example_data/example_chromatograms/Example_FID.csv', modulation_time = 20,                                           sampling_interval= 'infer', shift=0,                                             normalize='volume', solvent_cutoff=0) In\u00a0[26]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[27]: Copied! <pre>%matplotlib inline\nplt.figure(figsize=(10,10/1.615))\nplt.imshow(np.sqrt(np.sqrt(Chromatogram.chrom_2D)), cmap='viridis', extent=Chromatogram.limits, interpolation='bilinear', aspect='auto')\nplt.xlabel('Retention time 1 (min)')\nplt.ylabel('Retention time 2 (s)')\nplt.colorbar(label=r'$\\sqrt{\\mathrm{intensity}}$')\nplt.xlim(0,106)\n# plt.savefig('test.png', dpi=1000, bbox_inches='tight')\n</pre> %matplotlib inline plt.figure(figsize=(10,10/1.615)) plt.imshow(np.sqrt(np.sqrt(Chromatogram.chrom_2D)), cmap='viridis', extent=Chromatogram.limits, interpolation='bilinear', aspect='auto') plt.xlabel('Retention time 1 (min)') plt.ylabel('Retention time 2 (s)') plt.colorbar(label=r'$\\sqrt{\\mathrm{intensity}}$') plt.xlim(0,106) # plt.savefig('test.png', dpi=1000, bbox_inches='tight')  Out[27]: <pre>(0.0, 106.0)</pre> In\u00a0[28]: Copied! <pre>masked_chromatogram = gcgc.mask_chromatogram(Chromatogram.chrom_2D, '../../example_data/example_masks/Mask_1.tif')\n\nplt.figure(figsize=(10,10/1.615))\nplt.imshow(np.sqrt(masked_chromatogram), cmap='viridis', extent=Chromatogram.limits, interpolation='bilinear', aspect='auto') # type: ignore\nplt.xlabel('Retention time 1 (min)')\nplt.ylabel('Retention time 2 (s)')\nplt.colorbar(label=r'$\\sqrt{\\mathrm{intensity}}$')\nplt.xlim(0,106)\n# plt.savefig('test.png', dpi=1000, bbox_inches='tight')\n</pre> masked_chromatogram = gcgc.mask_chromatogram(Chromatogram.chrom_2D, '../../example_data/example_masks/Mask_1.tif')  plt.figure(figsize=(10,10/1.615)) plt.imshow(np.sqrt(masked_chromatogram), cmap='viridis', extent=Chromatogram.limits, interpolation='bilinear', aspect='auto') # type: ignore plt.xlabel('Retention time 1 (min)') plt.ylabel('Retention time 2 (s)') plt.colorbar(label=r'$\\sqrt{\\mathrm{intensity}}$') plt.xlim(0,106) # plt.savefig('test.png', dpi=1000, bbox_inches='tight') Out[28]: <pre>(0.0, 106.0)</pre> In\u00a0[34]: Copied! <pre>%matplotlib inline\nfrom matplotlib.colors import ListedColormap\nimport tifffile\n\nimport os\nmaskdir = '../../example_data/example_masks/'\nmask_list = os.listdir(maskdir)\n\nplt.figure(figsize=(10,10/1.615))\nplt.imshow(np.sqrt(Chromatogram.chrom_2D), cmap='viridis', extent=Chromatogram.limits, interpolation='bilinear', aspect='auto')\nplt.xlabel('Retention time 1 (min)')\nplt.ylabel('Retention time 2 (s)')\nplt.colorbar(label=r'$\\sqrt{\\mathrm{intensity}}$')\n\n\n\ncolormaplist = [ListedColormap(['none', 'C'+str(i)]) for i in range(6) ]\nannotations = [['Alkanes/Alkenes',28,7],['Monoaromatics',50,12],['Diaromatics',30,19],['Triaromatics',64,4.5],['Pyrenes',93,8]]\n\nfor i in range(len(mask_list)):\n    mask =  tifffile.imread(maskdir + mask_list[i])/255 # if the mask is binary no need to divide by 255\n    plt.imshow(mask, cmap=colormaplist[i], interpolation='nearest', extent=Chromatogram.limits, aspect='auto', alpha=0.2)\n    plt.text(annotations[i][1], annotations[i][2], annotations[i][0], fontsize=8, color='white')\n\nplt.xlim(0,106)\n\nResults_dict = gcgc.integrate_masks(Chromatogram.chrom_2D, masks =  maskdir, mask_names = 'infer')\n# Since Results_dict contains scalar values for each mask, you can simply create the DataFrame from the dict directly:\nOutput_df = pd.DataFrame([Results_dict], index=['Sample 1'])\nOutput_df\n# plt.savefig('test.png', dpi=1000, bbox_inches='tight')\n</pre> %matplotlib inline from matplotlib.colors import ListedColormap import tifffile  import os maskdir = '../../example_data/example_masks/' mask_list = os.listdir(maskdir)  plt.figure(figsize=(10,10/1.615)) plt.imshow(np.sqrt(Chromatogram.chrom_2D), cmap='viridis', extent=Chromatogram.limits, interpolation='bilinear', aspect='auto') plt.xlabel('Retention time 1 (min)') plt.ylabel('Retention time 2 (s)') plt.colorbar(label=r'$\\sqrt{\\mathrm{intensity}}$')    colormaplist = [ListedColormap(['none', 'C'+str(i)]) for i in range(6) ] annotations = [['Alkanes/Alkenes',28,7],['Monoaromatics',50,12],['Diaromatics',30,19],['Triaromatics',64,4.5],['Pyrenes',93,8]]  for i in range(len(mask_list)):     mask =  tifffile.imread(maskdir + mask_list[i])/255 # if the mask is binary no need to divide by 255     plt.imshow(mask, cmap=colormaplist[i], interpolation='nearest', extent=Chromatogram.limits, aspect='auto', alpha=0.2)     plt.text(annotations[i][1], annotations[i][2], annotations[i][0], fontsize=8, color='white')  plt.xlim(0,106)  Results_dict = gcgc.integrate_masks(Chromatogram.chrom_2D, masks =  maskdir, mask_names = 'infer') # Since Results_dict contains scalar values for each mask, you can simply create the DataFrame from the dict directly: Output_df = pd.DataFrame([Results_dict], index=['Sample 1']) Output_df # plt.savefig('test.png', dpi=1000, bbox_inches='tight') Out[34]: Mask_1 Mask_2 Sample 1 0.792885 0.137872"},{"location":"notebooks/Develop_notebook.html#dev-notebook","title":"Dev Notebook\u00b6","text":""},{"location":"notebooks/Develop_notebook.html#parsing-and-plotting","title":"Parsing and Plotting\u00b6","text":""},{"location":"notebooks/Develop_notebook.html#masking","title":"Masking\u00b6","text":""},{"location":"notebooks/Develop_notebook.html#masking-integrating","title":"Masking &amp; Integrating\u00b6","text":""},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>pyGCxGC<ul> <li>gui<ul> <li>mask_creator</li> <li>mask_creator_cli</li> </ul> </li> <li>main</li> <li>mask_gui</li> <li>parsing</li> <li>processing</li> </ul> </li> </ul>"},{"location":"reference/pyGCxGC/main.html","title":"main","text":""},{"location":"reference/pyGCxGC/main.html#pyGCxGC.main.GCxGC_FID","title":"<code>GCxGC_FID</code>","text":"<p>A class representing a GCxGC-FID (Gas Chromatography x Gas Chromatography - Flame Ionization Detector) dataset.</p> <p>This class handles the processing and analysis of data from comprehensive two-dimensional gas chromatography experiments.</p> <p>Parameters:</p> Name Type Description Default <code>chrom_1D</code> <code>DataFrame</code> <p>DataFrame containing the one-dimensional chromatogram data with retention times.</p> required <code>chrom_2D</code> <code>DataFrame</code> <p>DataFrame containing the two-dimensional chromatogram data.</p> required <code>sampling_interval</code> <code>float</code> <p>The time interval between consecutive data points in seconds.</p> required <code>modulation_time</code> <code>float</code> <p>The modulation period used in the GCxGC system in seconds.</p> required <code>shift</code> <code>float</code> <p>A time shift correction to apply to the data, by default None.</p> <code>None</code> <code>solvent_cutoff</code> <code>float</code> <p>Retention time threshold to exclude solvent peak from analysis, by default None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>chrom_1D</code> <code>DataFrame</code> <p>One-dimensional chromatogram data.</p> <code>chrom_2D</code> <code>DataFrame</code> <p>Two-dimensional chromatogram data.</p> <code>sampling_interval</code> <code>float</code> <p>The time interval between consecutive data points.</p> <code>modulation_time</code> <code>float</code> <p>The modulation period of the GCxGC system.</p> <code>shift</code> <code>float or None</code> <p>The time shift correction applied to the data.</p> <code>solvent_cutoff</code> <code>float or None</code> <p>The retention time threshold used to exclude solvent peaks.</p> <code>name</code> <code>str or None</code> <p>Name identifier for the dataset.</p> <code>date</code> <code>str or None</code> <p>Date of the chromatographic analysis.</p> <code>limits</code> <code>list</code> <p>Boundaries of the chromatogram data [min_1D_time(min), max_1D_time(min), min_2D_time, max_2D_time].</p> Source code in <code>pyGCxGC/main.py</code> <pre><code>class GCxGC_FID:\n    \"\"\"\n    A class representing a GCxGC-FID (Gas Chromatography x Gas Chromatography - Flame Ionization Detector) dataset.\n\n    This class handles the processing and analysis of data from comprehensive two-dimensional gas chromatography experiments.\n\n    Parameters\n    ----------\n    chrom_1D : pd.DataFrame\n        DataFrame containing the one-dimensional chromatogram data with retention times.\n    chrom_2D : pd.DataFrame\n        DataFrame containing the two-dimensional chromatogram data.\n    sampling_interval : float\n        The time interval between consecutive data points in seconds.\n    modulation_time : float\n        The modulation period used in the GCxGC system in seconds.\n    shift : float, optional\n        A time shift correction to apply to the data, by default None.\n    solvent_cutoff : float, optional\n        Retention time threshold to exclude solvent peak from analysis, by default None.\n\n    Attributes\n    ----------\n    chrom_1D : pd.DataFrame\n        One-dimensional chromatogram data.\n    chrom_2D : pd.DataFrame\n        Two-dimensional chromatogram data.\n    sampling_interval : float\n        The time interval between consecutive data points.\n    modulation_time : float\n        The modulation period of the GCxGC system.\n    shift : float or None\n        The time shift correction applied to the data.\n    solvent_cutoff : float or None\n        The retention time threshold used to exclude solvent peaks.\n    name : str or None\n        Name identifier for the dataset.\n    date : str or None\n        Date of the chromatographic analysis.\n    limits : list\n        Boundaries of the chromatogram data [min_1D_time(min), max_1D_time(min), min_2D_time, max_2D_time].\n    \"\"\"\n\n    def __init__(self, chrom_1D: pd.DataFrame, chrom_2D: pd.DataFrame, sampling_interval, modulation_time, shift=None, solvent_cutoff=None):\n        self.chrom_1D = chrom_1D\n        self.chrom_2D = chrom_2D\n        self.sampling_interval = sampling_interval\n        self.modulation_time = modulation_time\n        self.shift = shift\n        self.solvent_cutoff = solvent_cutoff\n        self.name = None\n        self.date = None\n        self.limits = [\n            self.chrom_1D['Ret.Time[s]'].min()/60,\n            self.chrom_1D['Ret.Time[s]'].max()/60,\n            self.chrom_2D.index.min(),\n            self.chrom_2D.index.max()\n        ]\n</code></pre>"},{"location":"reference/pyGCxGC/main.html#pyGCxGC.main.add_split","title":"<code>add_split(df, modulation_time, sampling_interval)</code>","text":"<p>Splits a DataFrame into segments based on the specified split time and sampling interval.</p> Parameters: <p>df : pandas.DataFrame     The input DataFrame containing chromatographic data. It is expected to have      an index that represents the time points of the data. modulation_time : float     The time duration (in s) for each split segment. sampling_interval : float     The time interval (in s) between consecutive data points in the DataFrame.</p> Returns: <p>pandas.DataFrame     The modified DataFrame with an additional column 'split_no_fromindex' that      indicates the split segment number for each row.</p> Source code in <code>pyGCxGC/main.py</code> <pre><code>def add_split(df,modulation_time,sampling_interval):#split time in s, sampling interval in ms\n    \"\"\"\n    Splits a DataFrame into segments based on the specified split time and sampling interval.\n\n    Parameters:\n    -----------\n    df : pandas.DataFrame\n        The input DataFrame containing chromatographic data. It is expected to have \n        an index that represents the time points of the data.\n    modulation_time : float\n        The time duration (in s) for each split segment.\n    sampling_interval : float\n        The time interval (in s) between consecutive data points in the DataFrame.\n    Returns:\n    --------\n    pandas.DataFrame\n        The modified DataFrame with an additional column 'split_no_fromindex' that \n        indicates the split segment number for each row.\n        \"\"\"\n    rows_splitting = modulation_time/sampling_interval*1000\n    df['split_no_fromindex'] = df.index//rows_splitting \n    while len(df[df['split_no_fromindex']==df['split_no_fromindex'].max()]) &lt; len(df[df['split_no_fromindex']==df['split_no_fromindex'].min()]):\n        df.loc[len(df)+1] = df.iloc[-1]\n    return df\n</code></pre>"},{"location":"reference/pyGCxGC/main.html#pyGCxGC.main.baseline_stridewise","title":"<code>baseline_stridewise(df_array)</code>","text":"<p>Subtracts the minimum in each stride as baseline</p> Source code in <code>pyGCxGC/main.py</code> <pre><code>def baseline_stridewise(df_array):\n    \"\"\"\n    Subtracts the minimum in each stride as baseline\n    \"\"\"\n    df_array = df_array - df_array.min(axis=0)\n    return df_array\n</code></pre>"},{"location":"reference/pyGCxGC/main.html#pyGCxGC.main.convert_to2D","title":"<code>convert_to2D(df, modulation_time)</code>","text":"<p>Generates a 2D Chromatogram from a 1D chromatogram DataFrame. Arguments: df : pandas.DataFrame     The input DataFrame containing chromatographic data. It is expected to have      columns 'split_no_fromindex' and 'Absolute Intensity'. modulation_time : float     The time duration (in s) for each split segment.</p> Returns: <p>pandas.DataFrame     A 2D DataFrame where the index represents the retention time and the columns      represent the split time. The values in the DataFrame are the absolute intensities.</p> Source code in <code>pyGCxGC/main.py</code> <pre><code>def convert_to2D(df:pd.DataFrame, modulation_time:float)-&gt;pd.DataFrame:\n    \"\"\"\n    Generates a 2D Chromatogram from a 1D chromatogram DataFrame.\n    Arguments:\n    df : pandas.DataFrame\n        The input DataFrame containing chromatographic data. It is expected to have \n        columns 'split_no_fromindex' and 'Absolute Intensity'.\n    modulation_time : float\n        The time duration (in s) for each split segment.\n    Returns:\n    --------\n    pandas.DataFrame\n        A 2D DataFrame where the index represents the retention time and the columns \n        represent the split time. The values in the DataFrame are the absolute intensities.\n    \"\"\"\n\n    df_short = df[['split_no_fromindex','Absolute Intensity']]\n    array_list = []\n\n    for i in range(0,int(df_short['split_no_fromindex'].max())):\n        array_list.append(df_short[df_short['split_no_fromindex']==i]['Absolute Intensity'].values)\n\n    #turn arraylist into an 2D array\n    array = np.zeros((len(array_list),len(array_list[0])))\n    for i in range(0,len(array_list)):\n        array[i,:] = array_list[i]\n\n    index_list_retention_time = []\n    for i in range(len(array_list)):\n        index_list_retention_time.append(i*modulation_time)\n\n    columns_splittime = []\n    for i in range(len(array_list[0])):\n        columns_splittime.append(round(i*modulation_time/len(array_list[0]),3))\n\n    df_array = pd.DataFrame(array, index = index_list_retention_time, columns = columns_splittime)\n    df_array= df_array.T\n    df_array = df_array.iloc[::-1]\n    return df_array\n</code></pre>"},{"location":"reference/pyGCxGC/main.html#pyGCxGC.main.is_integer_multiple","title":"<code>is_integer_multiple(larger, smaller, tolerance=1e-10)</code>","text":"<p>Check if larger is an integer multiple of smaller within a tolerance.</p> Source code in <code>pyGCxGC/main.py</code> <pre><code>def is_integer_multiple(larger, smaller, tolerance=1e-10):\n    \"\"\"Check if larger is an integer multiple of smaller within a tolerance.\"\"\"\n    ratio = larger / smaller\n    return abs(round(ratio) - ratio) &lt; tolerance\n</code></pre>"},{"location":"reference/pyGCxGC/main.html#pyGCxGC.main.normalize_by_volume","title":"<code>normalize_by_volume(df_array)</code>","text":"<p>Normalizes the Volume of a 2D chromatogram to 1. Arguments: df_array : pandas.DataFrame     The input 2D DataFrame representing the chromatogram. Index is the Retention time 2 (y), Columns are the Retention time 1 (x).</p> Returns: <p>pandas.DataFrame     The normalized 2D DataFrame.</p> Source code in <code>pyGCxGC/main.py</code> <pre><code>def normalize_by_volume(df_array):\n    \"\"\"\n    Normalizes the Volume of a 2D chromatogram to 1.\n    Arguments:\n    df_array : pandas.DataFrame\n        The input 2D DataFrame representing the chromatogram. Index is the Retention time 2 (y), Columns are the Retention time 1 (x).\n    Returns:\n    --------\n    pandas.DataFrame\n        The normalized 2D DataFrame.\n    \"\"\"\n    df_array_norm = df_array/integrate_2D(df_array)\n    return df_array_norm\n</code></pre>"},{"location":"reference/pyGCxGC/main.html#pyGCxGC.main.shift_phase","title":"<code>shift_phase(df_array, shift)</code>","text":"<p>Adjust the phase of a 2D chromatogram by shifting the rows. Arguments: df_array : pandas.DataFrame     The input 2D DataFrame representing the chromatogram. Index is the Retention time 2 (y), Columns are the Retention time 1 (x). shift : int     The number of rows to shift the DataFrame. Positive values shift down, negative values shift up.</p> Returns: <p>pandas.DataFrame     The shifted 2D DataFrame.</p> Source code in <code>pyGCxGC/main.py</code> <pre><code>def shift_phase(df_array, shift):\n    \"\"\"\n    Adjust the phase of a 2D chromatogram by shifting the rows.\n    Arguments:\n    df_array : pandas.DataFrame\n        The input 2D DataFrame representing the chromatogram. Index is the Retention time 2 (y), Columns are the Retention time 1 (x).\n    shift : int\n        The number of rows to shift the DataFrame. Positive values shift down, negative values shift up.\n    Returns:\n    --------\n    pandas.DataFrame\n        The shifted 2D DataFrame.\n    \"\"\"\n    columns = df_array.columns\n    indices = df_array.index\n    df_array_shifted = np.roll(df_array, shift, axis=0)\n    return pd.DataFrame(df_array_shifted, index=indices, columns=columns)\n</code></pre>"},{"location":"reference/pyGCxGC/main.html#pyGCxGC.main.split_solvent","title":"<code>split_solvent(df, solvent_time=0)</code>","text":"<p>Sets the intensity to 0 for rows in the DataFrame where the retention time is less than or equal to the specified solvent time.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame containing chromatographic data.  It must have columns 'Ret.Time[s]' and 'Absolute Intensity'.</p> required <code>solvent_time</code> <code>Union[int, float]</code> <p>The retention time threshold in minutes below which the intensity will be set to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The modified DataFrame with updated intensity values.</p> Source code in <code>pyGCxGC/main.py</code> <pre><code>def split_solvent(df: pd.DataFrame, solvent_time: Union[int, float] = 0) -&gt; pd.DataFrame:\n    \"\"\"\n    Sets the intensity to 0 for rows in the DataFrame where the retention time is less than or equal to the specified solvent time.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        The input DataFrame containing chromatographic data. \n        It must have columns 'Ret.Time[s]' and 'Absolute Intensity'.\n    solvent_time : Union[int, float], optional\n        The retention time threshold in minutes below which the intensity will be set to 0.\n\n    Returns\n    -------\n    pd.DataFrame\n        The modified DataFrame with updated intensity values.\n    \"\"\"\n    df.loc[df['Ret.Time[s]'] &lt;= solvent_time * 60, 'Absolute Intensity'] = 0\n    return df\n</code></pre>"},{"location":"reference/pyGCxGC/mask_gui.html","title":"mask_gui","text":"<p>Mask GUI module - provides functions to launch the mask creator GUI.</p>"},{"location":"reference/pyGCxGC/mask_gui.html#pyGCxGC.mask_gui.launch_mask_creator","title":"<code>launch_mask_creator()</code>","text":"<p>Launch the mask creator GUI.</p> <p>This function creates a new Tkinter window and starts the mask creator GUI application.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pyGCxGC as gcgc\n&gt;&gt;&gt; gcgc.launch_mask_creator()\n</code></pre> Source code in <code>pyGCxGC/mask_gui.py</code> <pre><code>def launch_mask_creator():\n    \"\"\"\n    Launch the mask creator GUI.\n\n    This function creates a new Tkinter window and starts the mask creator GUI application.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import pyGCxGC as gcgc\n    &gt;&gt;&gt; gcgc.launch_mask_creator()\n    \"\"\"\n    root = tk.Tk()\n\n    # Configure Liberation Sans font for all widgets\n    default_font = tkfont.nametofont(\"TkDefaultFont\")\n    default_font.configure(family=\"Liberation Sans\")\n\n    text_font = tkfont.nametofont(\"TkTextFont\")\n    text_font.configure(family=\"Liberation Sans\")\n\n    fixed_font = tkfont.nametofont(\"TkFixedFont\")\n    fixed_font.configure(family=\"Liberation Sans\")\n\n    app = MaskCreatorGUI(root)\n    root.mainloop()\n    return None\n</code></pre>"},{"location":"reference/pyGCxGC/parsing.html","title":"parsing","text":""},{"location":"reference/pyGCxGC/parsing.html#pyGCxGC.parsing.parse_2D_chromatogram","title":"<code>parse_2D_chromatogram(data, modulation_time, sampling_interval='infer', shift=0, baseline_type='stridewise', normalize='volume', solvent_cutoff=0, name=None)</code>","text":"<p>Parses a 2D chromatogram from input data (frame or file), applies preprocessing steps, and returns a processed 2D chromatogram.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame or str or PathLike</code> <p>The input chromatogram data. Can be a pandas DataFrame or a file path to a CSV file. If a DataFrame, it needs to contain the columns 'Ret.Time[s]' and 'Absolute Intensity'.</p> required <code>modulation_time</code> <code>float</code> <p>The modulation time in seconds.</p> required <code>sampling_interval</code> <code>float or str</code> <p>The sampling interval in milliseconds. If 'infer', it is calculated from the data.</p> <code>'infer'</code> <code>shift</code> <code>float</code> <p>Phase shift to apply to the 2D chromatogram.</p> <code>0</code> <code>baseline_type</code> <code>str or callable</code> <p>The type of baseline correction to apply. Options are: - 'stridewise': Applies stridewise subtraction of the minimum. - 'global': Subtracts the minimum absolute intensity as a global baseline. - callable: A custom function for baseline correction.</p> <code>'stridewise'</code> <code>normalize</code> <code>str</code> <p>The normalization method to apply. Options are: - 'volume': Normalizes by volume. - 'max': Normalizes by the maximum intensity. - None: No normalization is applied.</p> <code>'volume'</code> <code>solvent_cutoff</code> <code>float</code> <p>The solvent cutoff time in minutes. Signals below this value are set to zero.</p> <code>0</code> <p>Returns:</p> Type Description <code>GCxGC_FID</code> <p>A processed 2D chromatogram object containing the original and 2D chromatogram data.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>data</code> is not a pandas DataFrame or a valid file path.</p> <code>ValueError</code> <p>If <code>sampling_interval</code> is not a float or 'infer'.</p> <code>AssertionError</code> <p>If the sampling interval is not an integer multiple of the modulation time.</p> Notes <ul> <li>The function supports baseline correction and normalization.</li> <li>Padding to account for non-integer multiples of modulation time and sampling interval is not implemented.</li> </ul> Source code in <code>pyGCxGC/parsing.py</code> <pre><code>def parse_2D_chromatogram(\n    data: Union[pd.DataFrame, str, os.PathLike], \n    modulation_time: float, \n    sampling_interval: Union[float, str] = 'infer',\n    shift: float = 0, \n    baseline_type: Union[str, Callable] = 'stridewise',\n    normalize: str = 'volume', \n    solvent_cutoff: float = 0,\n    name: Union[str, None] = None\n) -&gt; gcgc.GCxGC_FID:\n    \"\"\"\n    Parses a 2D chromatogram from input data (frame or file), applies preprocessing steps, and returns a processed 2D chromatogram.\n\n    Parameters\n    ----------\n    data : pandas.DataFrame or str or os.PathLike\n        The input chromatogram data. Can be a pandas DataFrame or a file path to a CSV file.\n        If a DataFrame, it needs to contain the columns 'Ret.Time[s]' and 'Absolute Intensity'.\n    modulation_time : float\n        The modulation time in seconds.\n    sampling_interval : float or str, optional, default='infer'\n        The sampling interval in milliseconds. If 'infer', it is calculated from the data.\n    shift : float, optional, default=0\n        Phase shift to apply to the 2D chromatogram.\n    baseline_type : str or callable, optional, default='stridewise'\n        The type of baseline correction to apply. Options are:\n        - 'stridewise': Applies stridewise subtraction of the minimum.\n        - 'global': Subtracts the minimum absolute intensity as a global baseline.\n        - callable: A custom function for baseline correction.\n    normalize : str, optional, default='volume'\n        The normalization method to apply. Options are:\n        - 'volume': Normalizes by volume.\n        - 'max': Normalizes by the maximum intensity.\n        - None: No normalization is applied.\n    solvent_cutoff : float, optional, default=0\n        The solvent cutoff time in minutes. Signals below this value are set to zero.\n\n    Returns\n    -------\n    GCxGC_FID\n        A processed 2D chromatogram object containing the original and 2D chromatogram data.\n\n    Raises\n    ------\n    TypeError\n        If `data` is not a pandas DataFrame or a valid file path.\n    ValueError\n        If `sampling_interval` is not a float or 'infer'.\n    AssertionError\n        If the sampling interval is not an integer multiple of the modulation time.\n\n    Notes\n    -----\n    - The function supports baseline correction and normalization.\n    - Padding to account for non-integer multiples of modulation time and sampling interval is not implemented.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        chrom = data\n        if name is None:\n            name = 'Chromatogram'\n        elif type(name) is str:\n            name = name\n        else:\n            raise TypeError(f\"name must be a string, not {type(name)}\")\n    elif isinstance(data, (str, os.PathLike)):\n        chrom = parse_csv(data)\n        if name is None:\n            name = os.path.basename(data)\n        elif type(name) is str:\n            name = name\n        else:\n            raise TypeError(f\"name must be a string, not {type(name)}\")\n    else:\n        raise TypeError(f\"data must be a pandas DataFrame or a file path, not {type(data)}\")\n\n    # setting the Signal to 0 below the solvent cutoff\n    if solvent_cutoff &gt; 0:\n        chrom = gcgc.split_solvent(chrom, solvent_cutoff)\n    else:\n        pass\n\n    #checking whether the sampling interval is an integer multiple of the modulation time\n    if sampling_interval =='infer':\n        sampling_interval = 1000 * float(chrom['Ret.Time[s]'].diff()[1]) # type: ignore\n    elif isinstance(sampling_interval, str):\n        raise ValueError(f\"sampling_interval must be a float or 'infer', not {type(sampling_interval)}\")\n\n    # asserting that the modulation time is an integer multiple of the sampling interval\n    assert gcgc.is_integer_multiple(modulation_time, sampling_interval),\\\n        f\"Sampling interval {sampling_interval} is not an integer multiple of the modulation time {modulation_time}.\\\n        \\n Padding to account for this is not implemented\"\n\n\n    # 2D generation\n    chrom = gcgc.add_split(chrom,modulation_time,sampling_interval)\n    chrom_2D = gcgc.convert_to2D(chrom,modulation_time)\n    if shift != 0 :\n        chrom_2D = gcgc.shift_phase(chrom_2D, shift)\n\n    #Baseline correction\n    if baseline_type == 'stridewise':\n        chrom_2D = gcgc.baseline_stridewise(chrom_2D)\n    elif baseline_type == 'global':\n        chrom_2D = chrom_2D - chrom['Absolute Intensity'].min()\n\n    elif callable(baseline_type): # type: ignore\n        chrom_2D = baseline_type(chrom_2D)\n    else:\n        pass\n\n    #Normalization\n    if normalize == 'volume':\n        chrom_2D = gcgc.normalize_by_volume(chrom_2D)\n    elif normalize == 'max':\n        chrom_2D = chrom_2D / chrom_2D.max()\n    else:\n        print('No normalization applied')\n\n\n    # make a 2D chromatogram class\n    Output = gcgc.GCxGC_FID(chrom, chrom_2D, modulation_time=modulation_time, sampling_interval=sampling_interval, shift=shift, solvent_cutoff=solvent_cutoff) # type: ignore\n    Output.name = name # type: ignore\n\n\n    return Output\n</code></pre>"},{"location":"reference/pyGCxGC/parsing.html#pyGCxGC.parsing.parse_csv","title":"<code>parse_csv(path)</code>","text":"<p>Reads a OpenChrom csv file and returns a pandas dataframe</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or PathLike</code> <p>The path to the CSV file.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas DataFrame containing the parsed chromatogram data with columns: - 'Ret.Time[s]': Retention time in seconds. - 'Absolute Intensity': Absolute intensity values.</p> Source code in <code>pyGCxGC/parsing.py</code> <pre><code>def parse_csv(path)-&gt;pd.DataFrame: #from a CSV file\n    \"\"\"\n    Reads a OpenChrom csv file and returns a pandas dataframe\n\n    Parameters\n    ----------\n    path : str or os.PathLike\n        The path to the CSV file.\n\n    Returns\n    -------\n    pd.DataFrame\n        A pandas DataFrame containing the parsed chromatogram data with columns:\n        - 'Ret.Time[s]': Retention time in seconds.\n        - 'Absolute Intensity': Absolute intensity values.\n    \"\"\"\n    df = pd.read_csv(path, sep = ',',  skiprows = 1)\n    df.columns = ['Time(ms)', 'Time(min)', 'unknown','Absolute Intensity']\n    df['Ret.Time'] = df['Time(min)']\n    df['Ret.Time']-=df['Ret.Time'][0]\n    df['Ret.Time[s]']=df['Ret.Time']*60\n    df.drop(['Time(ms)','Time(min)','unknown'], axis=1, inplace=True)\n    return df\n</code></pre>"},{"location":"reference/pyGCxGC/processing.html","title":"processing","text":""},{"location":"reference/pyGCxGC/processing.html#pyGCxGC.processing.integrate_2D","title":"<code>integrate_2D(Chrom_2D)</code>","text":"<p>Integrates a 2D chromatogram by integrating over the rows and then over the columns. Arguments: Chrom_2D : pandas.DataFrame     The input 2D DataFrame representing the chromatogram. Index is the Retention time 2 (y), Columns are the Retention time 1 (x).</p> Returns: <p>float     The integrated volume of the 2D chromatogram.</p> Source code in <code>pyGCxGC/processing.py</code> <pre><code>def integrate_2D(Chrom_2D: Union[pd.DataFrame, np.ndarray]) -&gt; float:\n    \"\"\"\n    Integrates a 2D chromatogram by integrating over the rows and then over the columns.\n    Arguments:\n    Chrom_2D : pandas.DataFrame\n        The input 2D DataFrame representing the chromatogram. Index is the Retention time 2 (y), Columns are the Retention time 1 (x).\n    Returns:\n    --------\n    float\n        The integrated volume of the 2D chromatogram.\n    \"\"\"\n    array_for_integral = np.array(Chrom_2D)\n    #integrate over rows\n    row_integrated_chrom = trapezoid(array_for_integral, axis=0)\n    #integrate over columns\n    volume = trapezoid(row_integrated_chrom, axis=0)\n    return volume\n</code></pre>"},{"location":"reference/pyGCxGC/processing.html#pyGCxGC.processing.integrate_masks","title":"<code>integrate_masks(chromatogram_2D, masks, mask_names='infer')</code>","text":"<p>Applies a list of masks to a 2D chromatogram and returns the integrated areas of the masked regions.</p> <p>Parameters:</p> Name Type Description Default <code>chromatogram_2D</code> <code>Union[DataFrame, ndarray]</code> <p>2D chromatogram to be integrated.</p> required <code>masks</code> <code>Union[list, PathLike, str]</code> <p>List of mask paths or a path to a directory containing the masks. The masks must be .tif files.</p> required <code>mask_names</code> <code>Union[list, str]</code> <p>List of names for the masks, or 'infer' to infer from filenames.</p> <code>'infer'</code> <p>Returns:</p> Name Type Description <code>Integrals</code> <code>dict</code> <p>A dictionary where the keys are the names of the masks and the values are the integrated areas of the masked regions.</p> Source code in <code>pyGCxGC/processing.py</code> <pre><code>def integrate_masks(chromatogram_2D: Union[pd.DataFrame, np.ndarray], masks: Union[list, os.PathLike, str], mask_names: Union[list, str] = 'infer') -&gt; dict:\n    \"\"\"\n    Applies a list of masks to a 2D chromatogram and returns the integrated areas of the masked regions.\n\n    Parameters\n    ----------\n    chromatogram_2D : Union[pd.DataFrame, np.ndarray]\n        2D chromatogram to be integrated.\n    masks : Union[list, os.PathLike, str]\n        List of mask paths or a path to a directory containing the masks.\n        The masks must be .tif files.\n    mask_names : Union[list, str]\n        List of names for the masks, or 'infer' to infer from filenames.\n\n    Returns\n    -------\n    Integrals : dict\n        A dictionary where the keys are the names of the masks and the values are the integrated areas of the masked regions.\n    \"\"\"\n    # Determine mask paths\n    if isinstance(masks, (str, os.PathLike)):\n        mask_dir = str(masks)\n        mask_list = [os.path.join(mask_dir, f) for f in os.listdir(mask_dir) if f.lower().endswith('.tif')]\n        if len(mask_list) == 0:\n            raise ValueError('No .tif masks found in the provided directory')\n    elif isinstance(masks, list):\n        mask_list = masks\n        if len(mask_list) == 0:\n            raise ValueError('The mask list is empty')\n    else:\n        raise TypeError('masks must be a list of paths or a path to a directory containing the masks')\n\n    # Infer mask names if needed\n    if mask_names == 'infer':\n        mask_names = [os.path.splitext(os.path.basename(mask))[0] for mask in mask_list]\n    elif isinstance(mask_names, list):\n        if len(mask_names) != len(mask_list):\n            raise ValueError('Length of mask_names does not match number of masks')\n    else:\n        raise TypeError('mask_names must be a list or \"infer\"')\n\n    Integrals = {}\n    for i, mask_path in enumerate(mask_list):\n        masked = mask_chromatogram(chromatogram_2D, mask_path)\n        if not isinstance(masked, pd.DataFrame):\n            masked = pd.DataFrame(masked)\n        Integral = integrate_2D(masked)\n        Integrals[mask_names[i]] = Integral\n\n    return Integrals\n</code></pre>"},{"location":"reference/pyGCxGC/processing.html#pyGCxGC.processing.mask_chromatogram","title":"<code>mask_chromatogram(chromatogram, mask_path)</code>","text":"<p>Masks the chromatogram by multiplication with a binary mask.</p> <p>Parameters:</p> Name Type Description Default <code>chromatogram</code> <code>Chromatogram</code> <p>The chromatogram to be masked.</p> required <code>mask_path</code> <code>str</code> <p>The path to the mask file. The mask needs to be a binary mask saved as .tif with the exact same dimensions as the chromatogram. To generate a mask, you can save the 2D chromatogram as a .tif file and then use an image processing software such as ImageJ to create a binary mask.</p> required <p>Returns:</p> Name Type Description <code>masked_chromatogram</code> <code>Chromatogram</code> <p>The masked chromatogram.</p> Source code in <code>pyGCxGC/processing.py</code> <pre><code>def mask_chromatogram(chromatogram: Union[pd.DataFrame, np.ndarray], mask_path: Union[str, os.PathLike])-&gt; Union[pd.DataFrame, np.ndarray]:\n    \"\"\"\n    Masks the chromatogram by multiplication with a binary mask.\n\n    Parameters\n    ----------\n    chromatogram : Chromatogram\n        The chromatogram to be masked.\n    mask_path : str\n        The path to the mask file. The mask needs to be a binary mask saved as .tif with the exact same dimensions as the chromatogram.\n        To generate a mask, you can save the 2D chromatogram as a .tif file and then use an image processing software such as ImageJ to create a binary mask.\n\n    Returns\n    -------\n    masked_chromatogram : Chromatogram\n        The masked chromatogram.\n    \"\"\"\n    mask = tifffile.imread(mask_path)\n    if mask.shape != chromatogram.shape:\n        raise ValueError(f\"Mask shape {mask.shape} does not match chromatogram shape {chromatogram.shape}.\")\n    if np.max(mask) == 255:\n        unique, counts = np.unique(mask, return_counts=True)\n        mask = mask / 255\n    if np.max(mask) == 1:\n        mask = mask\n    masked_chromatogram = chromatogram * mask\n    return masked_chromatogram\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html","title":"mask_creator","text":"<p>This module provides a GUI for creating masks for 2D chromatograms.</p>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.MaskCreatorGUI","title":"<code>MaskCreatorGUI</code>","text":"<p>A GUI for creating and editing masks for 2D chromatograms.</p> <p>This class provides a graphical interface for: - Loading and displaying 2D chromatograms - Drawing masks using different tools (rectangle, lasso, polygon) - Saving masks as .tif files for use with pyGCxGC</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>class MaskCreatorGUI:\n    \"\"\"\n    A GUI for creating and editing masks for 2D chromatograms.\n\n    This class provides a graphical interface for:\n    - Loading and displaying 2D chromatograms\n    - Drawing masks using different tools (rectangle, lasso, polygon)\n    - Saving masks as .tif files for use with pyGCxGC\n    \"\"\"\n\n    def __init__(self, root: tk.Tk):\n        \"\"\"\n        Initialize the MaskCreatorGUI.\n\n        Parameters\n        ----------\n        root : tk.Tk\n            The root Tkinter window\n        \"\"\"\n        # Set matplotlib font to Liberation Sans\n        plt.rcParams['font.family'] = 'Liberation Sans'\n\n        self.root = root\n        self.root.title(\"pyGCxGC Mask Creator\")\n        self.root.geometry(\"1200x800\")\n\n        # Variables to store data\n        self.chromatogram = None  # Will hold the GCxGC_FID object\n        self.original_chromatogram = None  # Will hold the original unshifted chromatogram\n        self.mask = None          # Will hold the current mask\n        self.mask_name = tk.StringVar(value=\"New Mask\")\n\n        # Status message\n        self.status_var = tk.StringVar(value=\"Ready\")\n\n        # Current drawing mode\n        self.drawing_mode = tk.StringVar(value=\"rectangle\")\n\n        # Shift value for phase adjustment\n        self.shift_value = tk.IntVar(value=0)\n\n        # Transform option for chromatogram display\n        self.transform_mode = tk.StringVar(value=\"square root\")\n\n        # Setup UI\n        self._create_ui()\n\n        # Initialize selector (will be set when chromatogram is loaded)\n        self.selector = None\n        self.selected_points = []\n        self.current_mask_color = 'red'\n\n        # Create a reference for the polygon selector (separate from main selector)\n        self.polygon_selector = None\n\n        # Create a reference for the colorbar\n        self.cbar = None\n\n    def _create_ui(self):\n        \"\"\"Create the UI components\"\"\"\n        # Main frame layout\n        main_frame = ttk.Frame(self.root)\n        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n\n        # Left panel (controls)\n        left_frame = ttk.Frame(main_frame, width=300)\n        left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))\n\n        # Right panel (visualization)\n        right_frame = ttk.Frame(main_frame)\n        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)\n\n        # Create and add controls to left panel\n        self._create_left_panel(left_frame)\n\n        # Create matplotlib figure and canvas in right panel\n        self._create_right_panel(right_frame)\n\n        # Create status bar\n        status_frame = ttk.Frame(self.root)\n        status_frame.pack(side=tk.BOTTOM, fill=tk.X)\n\n        status_label = ttk.Label(status_frame, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)\n        status_label.pack(fill=tk.X, padx=5, pady=2)\n\n    def _create_left_panel(self, parent):\n        \"\"\"Create the left control panel\"\"\"\n        # Chromatogram load section\n        chrom_frame = ttk.LabelFrame(parent, text=\"Chromatogram\", padding=10)\n        chrom_frame.pack(fill=tk.X, pady=(0, 10))\n\n        load_btn = ttk.Button(\n            chrom_frame, \n            text=\"Load Chromatogram File\", \n            command=self._load_chromatogram\n        )\n        load_btn.pack(fill=tk.X, pady=5)\n        create_tooltip(load_btn, \"Load a 2D chromatogram from a CSV file\")\n\n        # Display current chromatogram\n        self.chrom_name_label = ttk.Label(chrom_frame, text=\"No chromatogram loaded\")\n        self.chrom_name_label.pack(fill=tk.X, pady=5)\n\n        # Plotting section\n        plotting_frame = ttk.LabelFrame(parent, text=\"Plotting\", padding=10)\n        plotting_frame.pack(fill=tk.X, pady=(0, 10))\n\n        # Create a two-column layout for compact arrangement\n        control_frame = ttk.Frame(plotting_frame)\n        control_frame.pack(fill=tk.X, pady=5)\n\n        # Left column - Shift controls\n        shift_frame = ttk.Frame(control_frame)\n        shift_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))\n\n        ttk.Label(shift_frame, text=\"Shift:\").pack(anchor=tk.W, pady=2)\n        shift_entry = ttk.Entry(\n            shift_frame, \n            textvariable=self.shift_value,\n            width=8\n        )\n        shift_entry.pack(fill=tk.X, pady=2)\n        create_tooltip(shift_entry, \"Enter shift value (integer) to adjust phase of the chromatogram\")\n\n        # Right column - Transform controls\n        transform_frame = ttk.Frame(control_frame)\n        transform_frame.pack(side=tk.RIGHT, fill=tk.X, expand=True, padx=(5, 0))\n\n        ttk.Label(transform_frame, text=\"Transform:\").pack(anchor=tk.W, pady=2)\n\n        transform_raw_btn = ttk.Radiobutton(\n            transform_frame, \n            text=\"Raw\",\n            variable=self.transform_mode,\n            value=\"raw\",\n            command=self._update_transform\n        )\n        transform_raw_btn.pack(anchor=tk.W, pady=1)\n        create_tooltip(transform_raw_btn, \"Display raw chromatogram data without transformation\")\n\n        transform_sqrt_btn = ttk.Radiobutton(\n            transform_frame, \n            text=\"Square Root\",\n            variable=self.transform_mode,\n            value=\"square root\",\n            command=self._update_transform\n        )\n        transform_sqrt_btn.pack(anchor=tk.W, pady=1)\n        create_tooltip(transform_sqrt_btn, \"Display square root of chromatogram data (default)\")\n\n        transform_thirdroot_btn = ttk.Radiobutton(\n            transform_frame, \n            text=\"Third Root\",\n            variable=self.transform_mode,\n            value=\"third root\",\n            command=self._update_transform\n        )\n        transform_thirdroot_btn.pack(anchor=tk.W, pady=1)\n        create_tooltip(transform_thirdroot_btn, \"Display third root of chromatogram data\")\n\n        # Apply button spanning the full width at the bottom\n        apply_shift_btn = ttk.Button(\n            plotting_frame, \n            text=\"Apply\", \n            command=self._apply_shift\n        )\n        apply_shift_btn.pack(fill=tk.X, pady=(10, 5))\n        create_tooltip(apply_shift_btn, \"Apply the shift and transform to the original chromatogram and update the display\")\n\n        # Drawing tools section\n        draw_frame = ttk.LabelFrame(parent, text=\"Drawing Tools\", padding=10)\n        draw_frame.pack(fill=tk.X, pady=(0, 10))\n\n        # Drawing mode options\n        rect_btn = ttk.Radiobutton(\n            draw_frame, \n            text=\"Rectangle\",\n            variable=self.drawing_mode,\n            value=\"rectangle\",\n            command=self._update_selector\n        )\n        rect_btn.pack(anchor=tk.W, pady=2)\n        create_tooltip(rect_btn, \"Draw rectangular selections on the chromatogram\")\n\n        lasso_btn = ttk.Radiobutton(\n            draw_frame, \n            text=\"Lasso\",\n            variable=self.drawing_mode,\n            value=\"lasso\",\n            command=self._update_selector\n        )\n        lasso_btn.pack(anchor=tk.W, pady=2)\n        create_tooltip(lasso_btn, \"Draw freeform selections on the chromatogram\")\n\n        polygon_btn = ttk.Radiobutton(\n            draw_frame, \n            text=\"Polygon\",\n            variable=self.drawing_mode,\n            value=\"polygon\",\n            command=self._update_selector\n        )\n        polygon_btn.pack(anchor=tk.W, pady=2)\n        create_tooltip(polygon_btn, \"Draw polygon selections with straight line segments on the chromatogram\")\n\n        # Clear button\n        clear_btn = ttk.Button(\n            draw_frame, \n            text=\"Clear Current Selection\", \n            command=self._clear_selection\n        )\n        clear_btn.pack(fill=tk.X, pady=5)\n        create_tooltip(clear_btn, \"Clear the current selection from the display\")\n\n        # Mask operations section\n        mask_frame = ttk.LabelFrame(parent, text=\"Mask Operations\", padding=10)\n        mask_frame.pack(fill=tk.X, pady=(0, 10))\n\n        # Mask name entry\n        ttk.Label(mask_frame, text=\"Mask Name:\").pack(anchor=tk.W, pady=2)\n        name_entry = ttk.Entry(\n            mask_frame, \n            textvariable=self.mask_name\n        )\n        name_entry.pack(fill=tk.X, pady=5)\n        create_tooltip(name_entry, \"Enter a name for your mask (used when saving)\")\n\n        # Add current selection to mask\n        add_btn = ttk.Button(\n            mask_frame, \n            text=\"Add Selection to Mask\", \n            command=self._add_to_mask\n        )\n        add_btn.pack(fill=tk.X, pady=5)\n        create_tooltip(add_btn, \"Add the current selection to the mask\")\n\n        # Create new empty mask\n        new_btn = ttk.Button(\n            mask_frame, \n            text=\"Create New Mask\", \n            command=self._create_new_mask\n        )\n        new_btn.pack(fill=tk.X, pady=5)\n        create_tooltip(new_btn, \"Create a new empty mask, discarding the current one\")\n\n        # Save/load mask buttons\n        save_btn = ttk.Button(\n            mask_frame, \n            text=\"Save Mask\", \n            command=self._save_mask\n        )\n        save_btn.pack(fill=tk.X, pady=5)\n        create_tooltip(save_btn, \"Save the current mask as a TIFF file\")\n\n        load_mask_btn = ttk.Button(\n            mask_frame, \n            text=\"Load Mask\", \n            command=self._load_mask\n        )\n        load_mask_btn.pack(fill=tk.X, pady=5)\n        create_tooltip(load_mask_btn, \"Load an existing mask from a TIFF file\")\n\n        # Help section\n        help_frame = ttk.LabelFrame(parent, text=\"Help\", padding=10)\n        help_frame.pack(fill=tk.X, pady=(0, 10))\n\n        help_text = (\n            \"1. Load a chromatogram\\n\"\n            \"2. (Optional) Adjust plotting\\n\"\n            \"   - Enter shift value\\n\"\n            \"   - Select transform (raw, sqrt, 3rd root)\\n\"\n            \"   - Click Apply\\n\"\n            \"3. Select drawing tool\\n\"\n            \"   - Rectangle: Click and drag\\n\"\n            \"   - Lasso: Free-form drawing\\n\"\n            \"   - Polygon: Click to add points\\n\"\n            \"4. Draw on the chromatogram\\n\"\n            \"5. Add selection to mask\\n\"\n            \"6. Save mask as .tif\\n\\n\"\n            \"Pan/Zoom: Use toolbar\"\n        )\n        ttk.Label(help_frame, text=help_text, justify=tk.LEFT).pack(fill=tk.X)\n\n    def _create_right_panel(self, parent):\n        \"\"\"Create the right visualization panel with matplotlib\"\"\"\n        # Create a frame for matplotlib figure\n        self.fig_frame = ttk.Frame(parent)\n        self.fig_frame.pack(fill=tk.BOTH, expand=True)\n\n        # Create Figure and Axes with constrained layout to handle colorbar properly\n        self.fig = Figure(figsize=(8, 6), dpi=100, constrained_layout=True)\n\n        # Set Liberation Sans font for all text in the figure\n        from matplotlib import rcParams\n        rcParams['font.family'] = 'Liberation Sans'\n\n        self.ax = self.fig.add_subplot(111)\n        self.ax.set_xlabel('Retention time 1 (min)')\n        self.ax.set_ylabel('Retention time 2 (s)')\n        self.ax.set_title('2D Chromatogram')\n\n        # Add the figure to the tkinter window\n        self.canvas = FigureCanvasTkAgg(self.fig, master=self.fig_frame)\n        self.canvas.draw()\n        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)\n\n        # Add toolbar\n        toolbar_frame = ttk.Frame(parent)\n        toolbar_frame.pack(fill=tk.X)\n        self.toolbar = NavigationToolbar2Tk(self.canvas, toolbar_frame)\n        self.toolbar.update()\n\n    def _load_chromatogram(self):\n        \"\"\"Load a chromatogram file\"\"\"\n        # Open file dialog for selecting a chromatogram\n        self.status_var.set(\"Selecting chromatogram file...\")\n        file_path = filedialog.askopenfilename(\n            title=\"Select a chromatogram file\",\n            filetypes=[(\"CSV files\", \"*.csv\"), (\"All files\", \"*.*\")]\n        )\n\n        if not file_path:\n            self.status_var.set(\"Ready\")\n            return\n\n        try:\n            # Ask for modulation time\n            self.status_var.set(\"Waiting for modulation time input...\")\n            modulation_dialog = tk.Toplevel(self.root)\n            modulation_dialog.title(\"Modulation Time\")\n            modulation_dialog.geometry(\"300x150\")\n            modulation_dialog.grab_set()\n\n            ttk.Label(modulation_dialog, text=\"Enter modulation time in seconds:\").pack(pady=10)\n\n            modulation_time_var = tk.DoubleVar(value=20.0)\n            modulation_entry = ttk.Entry(modulation_dialog, textvariable=modulation_time_var)\n            modulation_entry.pack(pady=10, padx=20, fill=tk.X)\n\n            # Button to confirm\n            def on_ok():\n                modulation_dialog.destroy()\n\n            ttk.Button(modulation_dialog, text=\"OK\", command=on_ok).pack(pady=10)\n\n            # Wait for dialog to close\n            self.root.wait_window(modulation_dialog)\n\n            modulation_time = modulation_time_var.get()\n\n            if modulation_time &lt;= 0:\n                messagebox.showerror(\"Error\", \"Modulation time must be greater than 0\")\n                self.status_var.set(\"Ready\")\n                return\n\n            # Load the chromatogram\n            self.status_var.set(f\"Loading chromatogram from {os.path.basename(file_path)}...\")\n            self.chromatogram = gcgc.parse_2D_chromatogram(\n                file_path, \n                modulation_time=modulation_time,\n                sampling_interval='infer'\n            )\n\n            # Store the original chromatogram for shift functionality\n            self.original_chromatogram = gcgc.parse_2D_chromatogram(\n                file_path, \n                modulation_time=modulation_time,\n                sampling_interval='infer'\n            )\n\n            # Reset shift value to 0 when loading new chromatogram\n            self.shift_value.set(0)\n\n            # Update UI\n            self.chrom_name_label.config(text=f\"Loaded: {self.chromatogram.name}\")\n\n            # Initialize an empty mask\n            self._create_new_mask()\n\n            # Display the chromatogram\n            self._display_chromatogram()\n\n            self.status_var.set(f\"Chromatogram loaded: {self.chromatogram.name}\")\n\n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to load chromatogram: {str(e)}\")\n            self.status_var.set(\"Error loading chromatogram\")\n\n    def _display_chromatogram(self):\n        \"\"\"Display the loaded chromatogram\"\"\"\n        if self.chromatogram is None:\n            return\n\n        self.status_var.set(\"Updating display...\")\n\n        # Remove any existing colorbar before clearing figure\n        if hasattr(self, 'cbar') and self.cbar is not None:\n            self.cbar.remove()\n            self.cbar = None\n\n        # Clear the figure completely\n        self.fig.clear()\n\n        # Recreate the axes\n        self.ax = self.fig.add_subplot(111)\n\n        # Apply transform based on selected mode\n        transform = self.transform_mode.get()\n        if transform == \"raw\":\n            transformed_data = self.chromatogram.chrom_2D\n            intensity_label = r'$\\mathrm{intensity}$'\n        elif transform == \"square root\":\n            transformed_data = np.sqrt(self.chromatogram.chrom_2D)\n            intensity_label = r'$\\sqrt{\\mathrm{intensity}}$'\n        elif transform == \"third root\":\n            transformed_data = np.power(self.chromatogram.chrom_2D, 1/3)\n            intensity_label = r'$\\sqrt[3]{\\mathrm{intensity}}$'\n        else:\n            # Default to square root if unknown transform\n            transformed_data = np.sqrt(self.chromatogram.chrom_2D)\n            intensity_label = r'$\\sqrt{\\mathrm{intensity}}$'\n\n        # Plot the chromatogram\n        im = self.ax.imshow(\n            transformed_data, \n            cmap='viridis', \n            extent=tuple(self.chromatogram.limits),\n            interpolation='bilinear', \n            aspect='auto'\n        )\n\n        # Create a single colorbar\n        # This is the only place we create a colorbar in the entire application\n        self.cbar = self.fig.colorbar(im, ax=self.ax)\n        self.cbar.set_label(intensity_label)\n\n        # Set labels\n        self.ax.set_xlabel('Retention time 1 (min)')\n        self.ax.set_ylabel('Retention time 2 (s)')\n        self.ax.set_title(f'2D Chromatogram: {self.chromatogram.name}')\n\n        # If mask exists, overlay it\n        if self.mask is not None:\n            # Create a color map for the mask: transparent for 0, red with alpha=0.3 for 1\n            mask_colors = np.zeros((self.chromatogram.chrom_2D.shape[0], self.chromatogram.chrom_2D.shape[1], 4))\n            mask_colors[self.mask == 1] = [1, 0, 0, 0.3]  # Red with alpha=0.3\n            self.ax.imshow(mask_colors, extent=tuple(self.chromatogram.limits), interpolation='nearest', aspect='auto')\n\n            # Count the number of masked pixels\n            masked_pixels = np.sum(self.mask)\n            total_pixels = self.mask.size\n            percent_masked = (masked_pixels / total_pixels) * 100\n\n            self.status_var.set(f\"Display updated. Mask covers {masked_pixels} pixels ({percent_masked:.2f}% of total)\")\n        else:\n            self.status_var.set(\"Display updated\")\n\n        # Update canvas\n        self.canvas.draw()\n\n        # Set up the selector\n        self._update_selector()\n\n    def _update_selector(self):\n        \"\"\"Update the selector based on the current drawing mode\"\"\"\n        if self.chromatogram is None:\n            return\n\n        # Remove existing selector and polygon selector if any\n        if self.selector is not None:\n            try:\n                self.selector.disconnect_events()\n            except:\n                pass\n            self.selector = None\n\n        if hasattr(self, 'polygon_selector') and self.polygon_selector is not None:\n            try:\n                self.polygon_selector.disconnect_events()\n            except:\n                pass\n            self.polygon_selector = None\n\n        # Create new selector based on current mode\n        if self.drawing_mode.get() == \"rectangle\":\n            self.selector = RectangleSelector(\n                self.ax, \n                self._on_rectangle_select,\n                useblit=True,\n                button=None,  # Use default button behavior\n                minspanx=5, \n                minspany=5,\n                spancoords='pixels',\n                interactive=True,\n                props=dict(color='white', alpha=0.2, fill=True)  # Use default button behavior\n            )\n        elif self.drawing_mode.get() == \"lasso\":\n            self.selector = LassoSelector(\n                self.ax, \n                self._on_lasso_select,\n                button=None,\n                props=dict(color='white')  # Use default button behavior\n            )\n        elif self.drawing_mode.get() == \"polygon\":\n            try:\n                # Create polygon selector with a handler that can be modified\n                self.polygon_selector = PolygonSelector(\n                    self.ax,\n                    lambda verts: None,  # Just a placeholder\n                    useblit=True,\n                    props=dict(color='white')\n                )\n\n                # Store original verts property getter\n                original_verts_property = type(self.polygon_selector).verts\n\n                # Define a handler that will be called when we add to mask\n                def get_polygon_vertices():\n                    # Get the vertices from the polygon selector\n                    if hasattr(self.polygon_selector, 'verts'):\n                        vertices = self.polygon_selector.verts\n                        if vertices and len(vertices) &gt; 0:\n                            # Set the selected points with the vertices\n                            self.selected_points = {\"type\": \"polygon\", \"vertices\": vertices}\n                            return True\n                    return False\n\n                # Store the handler for later use\n                self.get_polygon_vertices = get_polygon_vertices\n\n                # Set as the current selector\n                self.selector = self.polygon_selector\n            except Exception as e:\n                messagebox.showerror(\"Error\", f\"Failed to create polygon selector: {str(e)}\")\n                traceback.print_exc()\n                self.status_var.set(\"Error creating polygon selector\")\n\n    def _on_rectangle_select(self, eclick, erelease):\n        \"\"\"Callback for rectangle selection\"\"\"\n        # Get the selection in data coordinates\n        x1, y1 = eclick.xdata, eclick.ydata\n        x2, y2 = erelease.xdata, erelease.ydata\n\n        # Store the selection for later use - we're storing as a special format for rectangles\n        # to differentiate from polygon/lasso vertices\n        self.selected_points = {\"type\": \"rectangle\", \"coords\": [(min(x1, x2), min(y1, y2)), (max(x1, x2), max(y1, y2))]}\n\n        # Update status bar\n        area_rt1 = abs(x2 - x1)  # RT1 in minutes\n        area_rt2 = abs(y2 - y1)  # RT2 in seconds\n        self.status_var.set(f\"Rectangle selected: RT1 range = {min(x1, x2):.2f}-{max(x1, x2):.2f} min, RT2 range = {min(y1, y2):.2f}-{max(y1, y2):.2f} s\")\n\n    def _on_lasso_select(self, vertices):\n        \"\"\"Callback for lasso selection\"\"\"\n        # Store the lasso path with type identifier\n        self.selected_points = {\"type\": \"lasso\", \"vertices\": vertices}\n\n        # Update status bar\n        num_points = len(vertices)\n        self.status_var.set(f\"Lasso selection with {num_points} vertices completed\")\n\n    def _on_polygon_select(self, xdata, ydata):\n        \"\"\"Callback for polygon selection\"\"\"\n        # Store the polygon vertices as a list of (x,y) pairs with type identifier\n        vertices = list(zip(xdata, ydata))\n        self.selected_points = {\"type\": \"polygon\", \"vertices\": vertices}\n\n        # Update status bar\n        num_points = len(vertices)\n        self.status_var.set(f\"Polygon selection with {num_points} vertices completed\")\n\n    def _on_polygon_callback(self, vertices):\n        \"\"\"\n        Callback for polygon selector which takes vertices directly\n        This is needed because PolygonSelector may pass vertices in a different format\n        depending on matplotlib version\n        \"\"\"\n        # If vertices is already a list of points (x,y), use it directly\n        if len(vertices) &gt; 0 and isinstance(vertices[0], (list, tuple)):\n            self.selected_points = {\"type\": \"polygon\", \"vertices\": vertices}\n        # If it's an array of shape (n,2), convert to list of tuples\n        elif hasattr(vertices, 'shape') and len(vertices.shape) == 2 and vertices.shape[1] == 2:\n            self.selected_points = {\"type\": \"polygon\", \"vertices\": list(map(tuple, vertices))}\n        # Otherwise try to interpret vertices as x,y arrays\n        else:\n            try:\n                # Try to extract x and y from vertices\n                if hasattr(vertices, 'verts'):\n                    # Some versions provide vertices.verts\n                    vertex_points = vertices.verts\n                else:\n                    # Assume vertices is the points directly\n                    vertex_points = vertices\n\n                self.selected_points = {\"type\": \"polygon\", \"vertices\": list(map(tuple, vertex_points))}\n            except Exception as e:\n                print(f\"Error converting vertices: {e}\")\n                traceback.print_exc()\n                # Fallback - just store whatever we got\n                self.selected_points = {\"type\": \"polygon\", \"vertices\": vertices}\n\n        # Update status bar\n        num_points = len(self.selected_points[\"vertices\"])\n        self.status_var.set(f\"Polygon selection with {num_points} vertices completed\")\n\n    def _clear_selection(self):\n        \"\"\"Clear the current selection\"\"\"\n        self.selected_points = []\n        # Redraw the chromatogram and mask without the selection\n        self._display_chromatogram()\n        self.status_var.set(\"Selection cleared\")\n\n    def _create_new_mask(self):\n        \"\"\"Create a new empty mask with the same dimensions as the chromatogram\"\"\"\n        if self.chromatogram is None:\n            messagebox.showwarning(\"Warning\", \"Please load a chromatogram first\")\n            return\n\n        # Create an empty mask with the same dimensions as the chromatogram\n        self.mask = np.zeros_like(self.chromatogram.chrom_2D, dtype=np.uint8)\n\n        # # Update display\n        # self._display_chromatogram()\n        # messagebox.showinfo(\"Info\", \"New empty mask created\")\n\n    def _add_to_mask(self):\n        \"\"\"Add the current selection to the mask\"\"\"\n        if self.chromatogram is None or self.mask is None:\n            messagebox.showwarning(\"Warning\", \"Please load a chromatogram and create a mask first\")\n            return\n\n        # For polygon selection, get vertices from the active polygon selector\n        if self.drawing_mode.get() == \"polygon\" and hasattr(self, \"get_polygon_vertices\"):\n            # Update the selected_points from the polygon selector\n            if not self.get_polygon_vertices():\n                messagebox.showwarning(\"Warning\", \"No polygon vertices found\")\n                return\n\n        # Now check if we have selected points\n        if not self.selected_points:\n            messagebox.showwarning(\"Warning\", \"No selection to add\")\n            return\n\n        try:\n            self.status_var.set(\"Adding selection to mask...\")\n            # Convert the mask to a temporary array for manipulation\n            temp_mask = self.mask.copy()\n\n            # Convert data coordinates to pixel/array coordinates\n            # Note: In numpy arrays, the first index is row (y), the second is column (x)\n            # But in the display coordinates, x is the first dimension and y is the second\n            # For chromatograms, retention time 1 (minutes) is x-axis, retention time 2 (seconds) is y-axis\n            data_to_array_x = lambda x: int((x - self.chromatogram.limits[0]) / \n                                            (self.chromatogram.limits[1] - self.chromatogram.limits[0]) * \n                                            self.chromatogram.chrom_2D.shape[1])\n\n            # The y-axis starts at the top in display coordinates but at the bottom in array coordinates\n            # This is the source of the flipping issue - we need to invert the y-coordinate\n            data_to_array_y = lambda y: int((self.chromatogram.limits[3] - y) / \n                                            (self.chromatogram.limits[3] - self.chromatogram.limits[2]) * \n                                            self.chromatogram.chrom_2D.shape[0])\n\n            # Apply the selection to the mask based on the type of selected points we have\n            if isinstance(self.selected_points, dict) and \"type\" in self.selected_points:\n                selection_type = self.selected_points[\"type\"]\n\n                if selection_type == \"rectangle\":\n                    try:\n                        # Get rectangle coordinates from the two corner points\n                        (x1, y1), (x2, y2) = self.selected_points[\"coords\"]\n\n                        # Convert to array indices\n                        x1_idx = max(0, min(data_to_array_x(x1), self.mask.shape[1]-1))\n                        y1_idx = max(0, min(data_to_array_y(y1), self.mask.shape[0]-1))\n                        x2_idx = max(0, min(data_to_array_x(x2), self.mask.shape[1]-1))\n                        y2_idx = max(0, min(data_to_array_y(y2), self.mask.shape[0]-1))\n\n                        # Make sure x1_idx &lt;= x2_idx and y1_idx &lt;= y2_idx\n                        x1_idx, x2_idx = min(x1_idx, x2_idx), max(x1_idx, x2_idx)\n                        y1_idx, y2_idx = min(y1_idx, y2_idx), max(y1_idx, y2_idx)\n\n                        # Set the rectangle area to 1 in the mask\n                        temp_mask[y1_idx:y2_idx+1, x1_idx:x2_idx+1] = 1\n                        self.status_var.set(f\"Added rectangle selection to mask ({x2_idx-x1_idx+1}x{y2_idx-y1_idx+1} pixels)\")\n                    except Exception as e:\n                        messagebox.showerror(\"Error\", f\"Failed to process rectangle selection: {str(e)}\")\n                        traceback.print_exc()\n                        self.status_var.set(\"Error processing rectangle selection\")\n                        return\n\n                elif selection_type in [\"lasso\", \"polygon\"]:\n                    try:\n                        # Get the vertices\n                        vertices = self.selected_points[\"vertices\"]\n\n                        # Create a Path from the vertices\n                        path = Path(vertices)\n\n                        # Create a grid of points\n                        y, x = np.mgrid[:self.mask.shape[0], :self.mask.shape[1]]\n                        points = np.vstack((x.flatten(), y.flatten())).T\n\n                        # Get array to data transform for points\n                        array_to_data_x = lambda x: self.chromatogram.limits[0] + (x / self.mask.shape[1]) * (self.chromatogram.limits[1] - self.chromatogram.limits[0])\n\n                        # Invert the y coordinate to match the display orientation\n                        array_to_data_y = lambda y: self.chromatogram.limits[3] - (y / self.mask.shape[0]) * (self.chromatogram.limits[3] - self.chromatogram.limits[2])\n\n                        # Transform points to data coordinates\n                        points_data = np.vstack((array_to_data_x(points[:, 0]), array_to_data_y(points[:, 1]))).T\n\n                        # Check which points are inside the path\n                        mask_points = path.contains_points(points_data)\n                        mask_points = mask_points.reshape(self.mask.shape)\n\n                        # Set the selected area to 1 in the mask\n                        temp_mask[mask_points] = 1\n\n                        # Count the number of points added\n                        num_added = np.sum(mask_points)\n                        self.status_var.set(f\"Added {selection_type} selection to mask ({num_added} pixels)\")\n\n                    except Exception as e:\n                        messagebox.showerror(\"Error\", f\"Failed to process {selection_type} selection: {str(e)}\")\n                        traceback.print_exc()\n                        self.status_var.set(f\"Error processing {selection_type} selection\")\n                        return\n                else:\n                    messagebox.showerror(\"Error\", f\"Unknown selection type: {selection_type}\")\n                    return\n            else:\n                messagebox.showerror(\"Error\", \"Invalid selection format\")\n                return\n\n            # Update the mask\n            self.mask = temp_mask\n\n            # Redraw\n            self._display_chromatogram()\n\n            # Clear the selection\n            self.selected_points = []\n\n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to add selection to mask: {str(e)}\")\n            traceback.print_exc()\n            self.status_var.set(\"Error adding selection to mask\")\n\n    def _save_mask(self):\n        \"\"\"Save the current mask as a TIFF file\"\"\"\n        if self.chromatogram is None or self.mask is None:\n            messagebox.showwarning(\"Warning\", \"Please load a chromatogram and create a mask first\")\n            return\n\n        # Open file dialog for saving the mask\n        self.status_var.set(\"Selecting destination for mask file...\")\n        file_path = filedialog.asksaveasfilename(\n            title=\"Save Mask\",\n            defaultextension=\".tif\",\n            initialfile=f\"{self.mask_name.get()}.tif\",\n            filetypes=[(\"TIFF files\", \"*.tif\"), (\"All files\", \"*.*\")]\n        )\n\n        if not file_path:\n            self.status_var.set(\"Ready\")\n            return\n\n        try:\n            self.status_var.set(f\"Saving mask to {os.path.basename(file_path)}...\")\n            # Save the mask as a TIFF file (multiply by 255 to get binary mask)\n            tifffile.imwrite(file_path, self.mask * 255)\n            messagebox.showinfo(\"Success\", f\"Mask saved to {file_path}\")\n            self.status_var.set(f\"Mask saved to {os.path.basename(file_path)}\")\n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to save mask: {str(e)}\")\n            self.status_var.set(\"Error saving mask\")\n\n    def _load_mask(self):\n        \"\"\"Load a mask from a TIFF file\"\"\"\n        if self.chromatogram is None:\n            messagebox.showwarning(\"Warning\", \"Please load a chromatogram first\")\n            return\n\n        # Open file dialog for selecting a mask\n        self.status_var.set(\"Selecting mask file to load...\")\n        file_path = filedialog.askopenfilename(\n            title=\"Select a mask file\",\n            filetypes=[(\"TIFF files\", \"*.tif\"), (\"All files\", \"*.*\")]\n        )\n\n        if not file_path:\n            self.status_var.set(\"Ready\")\n            return\n\n        try:\n            self.status_var.set(f\"Loading mask from {os.path.basename(file_path)}...\")\n            # Load the mask\n            loaded_mask = tifffile.imread(file_path)\n\n            # Check if mask dimensions match the chromatogram\n            if loaded_mask.shape != self.chromatogram.chrom_2D.shape:\n                messagebox.showerror(\n                    \"Error\", \n                    f\"Mask dimensions {loaded_mask.shape} do not match chromatogram dimensions {self.chromatogram.chrom_2D.shape}\"\n                )\n                self.status_var.set(\"Error: Mask dimensions do not match chromatogram\")\n                return\n\n            # Normalize to binary (0 and 1)\n            if np.max(loaded_mask) == 255:\n                loaded_mask = loaded_mask / 255\n\n            self.mask = loaded_mask.astype(np.uint8)\n\n            # Set mask name from filename\n            mask_name = os.path.splitext(os.path.basename(file_path))[0]\n            self.mask_name.set(mask_name)\n\n            # Update display\n            self._display_chromatogram()\n            messagebox.showinfo(\"Success\", f\"Mask loaded from {file_path}\")\n            self.status_var.set(f\"Mask '{mask_name}' loaded successfully\")\n\n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to load mask: {str(e)}\")\n            self.status_var.set(\"Error loading mask\")\n\n    def _use_workspace_chromatogram(self):\n        \"\"\"Use a chromatogram from the current workspace variables\"\"\"\n        try:\n            # Get the list of variables in the user's namespace that are GCxGC_FID objects\n            import inspect\n            import sys\n\n            # Look for GCxGC_FID objects in the calling frame's namespace\n            frame = inspect.currentframe()\n            try:\n                # Go up frames until we find a frame with locals containing GCxGC_FID objects\n                while frame:\n                    frame_locals = frame.f_locals\n                    # Find GCxGC_FID objects\n                    chromatograms = {name: obj for name, obj in frame_locals.items() \n                                    if isinstance(obj, gcgc.GCxGC_FID)}\n                    if chromatograms:\n                        break\n                    frame = frame.f_back\n\n                if not chromatograms:\n                    # Look in globals as a last resort\n                    chromatograms = {name: obj for name, obj in frame.f_globals.items() \n                                    if isinstance(obj, gcgc.GCxGC_FID)}\n            finally:\n                del frame  # Avoid reference cycles\n\n            if not chromatograms:\n                messagebox.showinfo(\"Info\", \"No GCxGC_FID objects found in the current workspace\")\n                return\n\n            # Let the user choose which chromatogram to use\n            if len(chromatograms) == 1:\n                # Only one chromatogram available, use it directly\n                chrom_name = list(chromatograms.keys())[0]\n                self.chromatogram = chromatograms[chrom_name]\n            else:\n                # Multiple chromatograms available, let the user choose\n                chrom_name = tk.StringVar()\n                dialog = tk.Toplevel(self.root)\n                dialog.title(\"Select Chromatogram\")\n                dialog.geometry(\"300x200\")\n                dialog.grab_set()  # Make the dialog modal\n\n                ttk.Label(dialog, text=\"Select a chromatogram:\").pack(pady=10)\n\n                # Create a listbox with all chromatogram names\n                listbox = tk.Listbox(dialog)\n                listbox.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n\n                for name in chromatograms.keys():\n                    listbox.insert(tk.END, name)\n\n                # Select the first item by default\n                listbox.selection_set(0)\n\n                # Button to confirm selection\n                def on_select():\n                    selection = listbox.curselection()\n                    if selection:\n                        chrom_name.set(listbox.get(selection[0]))\n                        dialog.destroy()\n\n                ttk.Button(dialog, text=\"Select\", command=on_select).pack(pady=10)\n\n                # Wait for the dialog to be closed\n                self.root.wait_window(dialog)\n\n                # If user selected a chromatogram, use it\n                if chrom_name.get():\n                    self.chromatogram = chromatograms[chrom_name.get()]\n                else:\n                    return\n\n            # Update UI to show the selected chromatogram\n            self.chrom_name_label.config(text=f\"Loaded: {self.chromatogram.name}\")\n\n            # Store the original chromatogram for shift functionality  \n            self.original_chromatogram = self.chromatogram\n\n            # Reset shift value to 0 when loading new chromatogram\n            self.shift_value.set(0)\n\n            # Initialize an empty mask\n            self._create_new_mask()\n\n            # Display the chromatogram\n            self._display_chromatogram()\n\n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to use workspace chromatogram: {str(e)}\")\n            import traceback\n            traceback.print_exc()\n\n    def _apply_shift(self):\n        \"\"\"Apply shift to the original chromatogram and update display\"\"\"\n        if self.original_chromatogram is None:\n            messagebox.showwarning(\"Warning\", \"Please load a chromatogram first\")\n            return\n\n        try:\n            shift = self.shift_value.get()\n            self.status_var.set(f\"Applying shift of {shift} to chromatogram...\")\n\n            # Import the shift_phase function from main module\n            from pyGCxGC.main import shift_phase\n\n            # Apply shift to the original chromatogram data\n            if shift == 0:\n                # No shift needed, use original data\n                shifted_chrom_2d = self.original_chromatogram.chrom_2D\n            else:\n                shifted_chrom_2d = shift_phase(self.original_chromatogram.chrom_2D, shift)\n\n            # Create a new chromatogram object with the shifted data\n            # Import the GCxGC_FID class to create a new instance\n            import pyGCxGC.main as gcgc_main\n\n            # Create new chromatogram with shifted data\n            self.chromatogram = gcgc_main.GCxGC_FID(\n                chrom_1D=self.original_chromatogram.chrom_1D,\n                chrom_2D=shifted_chrom_2d,\n                sampling_interval=self.original_chromatogram.sampling_interval,\n                modulation_time=self.original_chromatogram.modulation_time,\n                shift=shift,\n                solvent_cutoff=self.original_chromatogram.solvent_cutoff\n            )\n\n            # Copy other attributes\n            self.chromatogram.name = self.original_chromatogram.name\n            self.chromatogram.date = self.original_chromatogram.date\n            self.chromatogram.limits = self.original_chromatogram.limits\n\n            # Update display\n            self._display_chromatogram()\n\n            if shift == 0:\n                self.status_var.set(\"Reset to original chromatogram (no shift)\")\n            else:\n                self.status_var.set(f\"Shift of {shift} applied successfully\")\n\n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to apply shift: {str(e)}\")\n            self.status_var.set(\"Error applying shift\")\n\n    def _update_transform(self):\n        \"\"\"Update the display when transform mode changes\"\"\"\n        if self.chromatogram is not None:\n            self._display_chromatogram()\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.MaskCreatorGUI.__init__","title":"<code>__init__(root)</code>","text":"<p>Initialize the MaskCreatorGUI.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Tk</code> <p>The root Tkinter window</p> required Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def __init__(self, root: tk.Tk):\n    \"\"\"\n    Initialize the MaskCreatorGUI.\n\n    Parameters\n    ----------\n    root : tk.Tk\n        The root Tkinter window\n    \"\"\"\n    # Set matplotlib font to Liberation Sans\n    plt.rcParams['font.family'] = 'Liberation Sans'\n\n    self.root = root\n    self.root.title(\"pyGCxGC Mask Creator\")\n    self.root.geometry(\"1200x800\")\n\n    # Variables to store data\n    self.chromatogram = None  # Will hold the GCxGC_FID object\n    self.original_chromatogram = None  # Will hold the original unshifted chromatogram\n    self.mask = None          # Will hold the current mask\n    self.mask_name = tk.StringVar(value=\"New Mask\")\n\n    # Status message\n    self.status_var = tk.StringVar(value=\"Ready\")\n\n    # Current drawing mode\n    self.drawing_mode = tk.StringVar(value=\"rectangle\")\n\n    # Shift value for phase adjustment\n    self.shift_value = tk.IntVar(value=0)\n\n    # Transform option for chromatogram display\n    self.transform_mode = tk.StringVar(value=\"square root\")\n\n    # Setup UI\n    self._create_ui()\n\n    # Initialize selector (will be set when chromatogram is loaded)\n    self.selector = None\n    self.selected_points = []\n    self.current_mask_color = 'red'\n\n    # Create a reference for the polygon selector (separate from main selector)\n    self.polygon_selector = None\n\n    # Create a reference for the colorbar\n    self.cbar = None\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.ToolTip","title":"<code>ToolTip</code>","text":"<p>Create a tooltip for a given widget</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>class ToolTip:\n    \"\"\"\n    Create a tooltip for a given widget\n    \"\"\"\n    def __init__(self, widget, text=''):\n        self.widget = widget\n        self.text = text\n        self.tipwindow = None\n        self.id = None\n        self.x = self.y = 0\n        self.widget.bind(\"&lt;Enter&gt;\", self.enter)\n        self.widget.bind(\"&lt;Leave&gt;\", self.leave)\n\n    def enter(self, event=None):\n        \"\"\"Display the tooltip when mouse enters the widget\"\"\"\n        self.schedule()\n\n    def leave(self, event=None):\n        \"\"\"Hide the tooltip when mouse leaves the widget\"\"\"\n        self.unschedule()\n        self.hidetip()\n\n    def schedule(self):\n        \"\"\"Schedule showing the tooltip\"\"\"\n        self.unschedule()\n        self.id = self.widget.after(500, self.showtip)\n\n    def unschedule(self):\n        \"\"\"Unschedule showing the tooltip\"\"\"\n        id = self.id\n        self.id = None\n        if id:\n            self.widget.after_cancel(id)\n\n    def showtip(self):\n        \"\"\"Show the tooltip\"\"\"\n        if self.tipwindow or not self.text:\n            return\n        x, y, cx, cy = self.widget.bbox(\"insert\")\n        x = x + self.widget.winfo_rootx() + 25\n        y = y + cy + self.widget.winfo_rooty() + 25\n        self.tipwindow = tw = tk.Toplevel(self.widget)\n        tw.wm_overrideredirect(True)\n        tw.wm_geometry(f\"+{x}+{y}\")\n        label = ttk.Label(tw, text=self.text, background=\"#ffffe0\",\n                           relief=tk.SOLID, borderwidth=1,\n                           wraplength=250, justify=tk.LEFT)\n        label.pack(padx=4, pady=4)\n\n    def hidetip(self):\n        \"\"\"Hide the tooltip\"\"\"\n        tw = self.tipwindow\n        self.tipwindow = None\n        if tw:\n            tw.destroy()\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.ToolTip.enter","title":"<code>enter(event=None)</code>","text":"<p>Display the tooltip when mouse enters the widget</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def enter(self, event=None):\n    \"\"\"Display the tooltip when mouse enters the widget\"\"\"\n    self.schedule()\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.ToolTip.hidetip","title":"<code>hidetip()</code>","text":"<p>Hide the tooltip</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def hidetip(self):\n    \"\"\"Hide the tooltip\"\"\"\n    tw = self.tipwindow\n    self.tipwindow = None\n    if tw:\n        tw.destroy()\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.ToolTip.leave","title":"<code>leave(event=None)</code>","text":"<p>Hide the tooltip when mouse leaves the widget</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def leave(self, event=None):\n    \"\"\"Hide the tooltip when mouse leaves the widget\"\"\"\n    self.unschedule()\n    self.hidetip()\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.ToolTip.schedule","title":"<code>schedule()</code>","text":"<p>Schedule showing the tooltip</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def schedule(self):\n    \"\"\"Schedule showing the tooltip\"\"\"\n    self.unschedule()\n    self.id = self.widget.after(500, self.showtip)\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.ToolTip.showtip","title":"<code>showtip()</code>","text":"<p>Show the tooltip</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def showtip(self):\n    \"\"\"Show the tooltip\"\"\"\n    if self.tipwindow or not self.text:\n        return\n    x, y, cx, cy = self.widget.bbox(\"insert\")\n    x = x + self.widget.winfo_rootx() + 25\n    y = y + cy + self.widget.winfo_rooty() + 25\n    self.tipwindow = tw = tk.Toplevel(self.widget)\n    tw.wm_overrideredirect(True)\n    tw.wm_geometry(f\"+{x}+{y}\")\n    label = ttk.Label(tw, text=self.text, background=\"#ffffe0\",\n                       relief=tk.SOLID, borderwidth=1,\n                       wraplength=250, justify=tk.LEFT)\n    label.pack(padx=4, pady=4)\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.ToolTip.unschedule","title":"<code>unschedule()</code>","text":"<p>Unschedule showing the tooltip</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def unschedule(self):\n    \"\"\"Unschedule showing the tooltip\"\"\"\n    id = self.id\n    self.id = None\n    if id:\n        self.widget.after_cancel(id)\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.create_tooltip","title":"<code>create_tooltip(widget, text)</code>","text":"<p>Create a tooltip for a widget</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def create_tooltip(widget, text):\n    \"\"\"Create a tooltip for a widget\"\"\"\n    return ToolTip(widget, text)\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator.html#pyGCxGC.gui.mask_creator.run_mask_creator","title":"<code>run_mask_creator()</code>","text":"<p>Run the MaskCreatorGUI application</p> Source code in <code>pyGCxGC/gui/mask_creator.py</code> <pre><code>def run_mask_creator():\n    \"\"\"\n    Run the MaskCreatorGUI application\n    \"\"\"\n    root = tk.Tk()\n    app = MaskCreatorGUI(root)\n    root.mainloop()\n</code></pre>"},{"location":"reference/pyGCxGC/gui/mask_creator_cli.html","title":"mask_creator_cli","text":"<p>Command-line script to launch the pyGCxGC Mask Creator GUI.</p>"},{"location":"reference/pyGCxGC/gui/mask_creator_cli.html#pyGCxGC.gui.mask_creator_cli.main","title":"<code>main()</code>","text":"<p>Main entry point for the mask creator GUI command-line script.</p> Source code in <code>pyGCxGC/gui/mask_creator_cli.py</code> <pre><code>def main():\n    \"\"\"\n    Main entry point for the mask creator GUI command-line script.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=\"Launch the pyGCxGC Mask Creator GUI\")\n    parser.add_argument(\"--version\", action=\"store_true\", help=\"Show version and exit\")\n\n    args = parser.parse_args()\n\n    if args.version:\n        import pyGCxGC\n        print(f\"pyGCxGC version {pyGCxGC.__version__}\")\n        return 0\n\n    # Launch the GUI\n    root = tk.Tk()\n    app = MaskCreatorGUI(root)\n    root.mainloop()\n\n    return 0\n</code></pre>"},{"location":"setup/install.html","title":"Installation","text":"<p>Install directly from TestPyPI, type this command in your : <pre><code>pip install -i https://test.pypi.org/simple/ pyGCxGC\n</code></pre></p>"},{"location":"setup/install.html#development-installation","title":"Development installation","text":"<p>If you want to install the development version:</p> <ul> <li>Clone the repository: <pre><code>git clone https://github.com/MyonicS/pyGCxGC\n</code></pre></li> <li>Install the package in development mode with dev dependencies by navigating to the cloned repository in your python environment and executing:</li> </ul> <pre><code>pip install -e .[dev,docs]\n</code></pre>"},{"location":"setup/python_start.html","title":"New to Python?","text":"<p>New to python and want to use pyTGA? Here is a quick guide:</p>"},{"location":"setup/python_start.html#install-a-distribution","title":"Install a distribution","text":"<p>The easiest way to get started with Python for scientific computing is with Anaconda: - Includes Python, package manager, and many scientific libraries - Provides a user-friendly interface (Anaconda Navigator) - Comes with Jupyter Notebook for interactive analysis - Handles most dependencies automatically</p>"},{"location":"setup/python_start.html#install-a-code-editor","title":"Install a code editor","text":"<p>To be able to write and run code, you should use a code editor such as - VS Code - a free, open-source editor with excellent Python support - Spyder - a scientific environment designed for Python</p>"},{"location":"setup/python_start.html#learn-the-basics","title":"Learn the basics","text":"<p>There are plenty of online tutorials availible. Here are some recommendations: - Boot.dev - sololearn</p>"},{"location":"setup/python_start.html#learn-about-the-most-important-libraries","title":"Learn about the most important libraries","text":"<p>For many applications in science, you wont need much more than these 3 libraries: - NumPy - fundamental package for scientific computing in Python - pandas - data analysis and manipulation library - Matplotlib - comprehensive library for plotting</p>"}]}